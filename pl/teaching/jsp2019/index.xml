<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Języki skryptowe - Python | Różański T.</title>
    <link>https://www.rozanskit.com/pl/teaching/jsp2019/</link>
      <atom:link href="https://www.rozanskit.com/pl/teaching/jsp2019/index.xml" rel="self" type="application/rss+xml" />
    <description>Języki skryptowe - Python</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>pl</language>
    <image>
      <url>https://www.rozanskit.com/images/icon_hu9eccabd213554be7652049b325691c23_30858_512x512_fill_lanczos_center_2.png</url>
      <title>Języki skryptowe - Python</title>
      <link>https://www.rozanskit.com/pl/teaching/jsp2019/</link>
    </image>
    
    <item>
      <title>Podstawowe informacje i instalacja Pythona</title>
      <link>https://www.rozanskit.com/pl/teaching/jsp2019/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.rozanskit.com/pl/teaching/jsp2019/introduction/</guid>
      <description>&lt;h3 id=&#34;gdzie-poczytaćo-pythonie&#34;&gt;Gdzie poczytać o Pythonie?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.python.org/moin/BeginnersGuide/NonProgrammers&#34;&gt;https://wiki.python.org/moin/BeginnersGuide/NonProgrammers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://python.cs.southern.edu/pythonbook/pythonbook.pdf&#34;&gt;https://python.cs.southern.edu/pythonbook/pythonbook.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pl.wikibooks.org/wiki/Zanurkuj_w_Pythonie&#34;&gt;https://pl.wikibooks.org/wiki/Zanurkuj_w_Pythonie&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A w praktyce najczęsciej będzie to: &lt;a href=&#34;https://stackoverflow.com/questions/tagged/python-3.x&#34;&gt;https://stackoverflow.com/questions/tagged/python-3.x&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;instalacja&#34;&gt;Instalacja&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.anaconda.com/anaconda/install/&#34;&gt;https://docs.anaconda.com/anaconda/install/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.anaconda.com/distribution/&#34;&gt;https://www.anaconda.com/distribution/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;czym-jest-jupyter-notebook&#34;&gt;Czym jest Jupyter Notebook?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://perseba.github.io/blog/jupyter-wprowadzenie.html&#34;&gt;http://perseba.github.io/blog/jupyter-wprowadzenie.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jupyter.readthedocs.io/en/latest/install.html&#34;&gt;https://jupyter.readthedocs.io/en/latest/install.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;czym-jest-conda&#34;&gt;Czym jest Conda?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.conda.io/en/latest/&#34;&gt;https://docs.conda.io/en/latest/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rekurencja (rekursja)</title>
      <link>https://www.rozanskit.com/pl/teaching/jsp2019/rekursja/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.rozanskit.com/pl/teaching/jsp2019/rekursja/</guid>
      <description>&lt;h3 id=&#34;co-to-jest-rekurencja&#34;&gt;Co to jest Rekurencja?&lt;/h3&gt;
&lt;p&gt;Zacznijmy od 
&lt;a href=&#34;https://www.google.com/search?q=recursion&amp;amp;oq=recursion&amp;amp;aqs=chrome.0.69i59j0l2j69i60l3.1383j0j7&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;żartu&lt;/a&gt;. Rekurencja (ang.&lt;em&gt;recursion&lt;/em&gt;) występuje, gdy definicja typu czy funkcji odwołuje się sama do siebie. Przykładem rekurencyjnej definicji funkcji może być definicja ciągu Fibonacciego:
$$
F_n =
\begin{cases}
1,&amp;amp; \text{if } x = 0\newline
1,&amp;amp; \text{if } x = 1\newline
F_{n-1} + F_{n-2},&amp;amp; \text{if } x \geq 2 \newline
\end{cases}
$$
A przykładem rekurencyjnej definicji struktury danych (typu) może być definicja listy jednokierunkowej:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct node
{
  int data;           // some integer data
  struct node *next;  // pointer to another struct node
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dzięki rekurencji łatwo można w prosty sposób zdefiniować niektóre zbiory fraktalne, np. trójkąt Sierpińskiego:








  











&lt;figure id=&#34;figure-trójkąt-sierpińskiego&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://www.rozanskit.com/media/jsp2020/Sierpinski_triangle_evolution.png&#34; data-caption=&#34;Trójkąt Sierpińskiego&#34;&gt;


  &lt;img src=&#34;https://www.rozanskit.com/media/jsp2020/Sierpinski_triangle_evolution.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Trójkąt Sierpińskiego
  &lt;/figcaption&gt;


&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;wieże-hanoi&#34;&gt;Wieże Hanoi&lt;/h3&gt;
&lt;p&gt;Mamy trzy stosy. Na jednym w nich od najmniejszego do największego (patrząc z góry) ułożone jest $N$ krążków. Pozostałe 2 stosy są puste. Zadanie polega na przeniesieniu krążków na wybrany z dwóch pozostałych stosów tak żeby zachować kolejność. Zasady:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jednocześnie przenosić można tylko jeden krążek,&lt;/li&gt;
&lt;li&gt;większy krążek nigdy nie może leżeć na mniejszym.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Można zajrzeć 
&lt;a href=&#34;http://www.javawithus.com/programs/towers-of-hanoi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tutaj&lt;/a&gt; po dokładniejszy opis.&lt;/p&gt;








  











&lt;figure id=&#34;figure-wieże-hanoi&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://www.rozanskit.com/media/jsp2020/NwAPw.gif&#34; data-caption=&#34;Wieże Hanoi&#34;&gt;


  &lt;img src=&#34;https://www.rozanskit.com/media/jsp2020/NwAPw.gif&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Wieże Hanoi
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;wyzwanie-1&#34;&gt;Wyzwanie 1.&lt;/h3&gt;
&lt;p&gt;Spróbuj na kartce papieru rozwiązać zagadkę dla 3 krążków.&lt;/p&gt;
&lt;h3 id=&#34;pseudokod-rozwiązania-rekurencyjnego&#34;&gt;Pseudokod rozwiązania rekurencyjnego&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function move(n, source, target, buffer):
    if n == 0:
       return

    # move n - 1 disks from source to helping tower, so they are out of the way
    move(n - 1, source, buffer, target)

    # move the nth disk from source to target
    target.append(source.pop())

    # move the n - 1 disks that we left on helping onto target
    move(n - 1, buffer, target, source)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;co-należy-zrobić&#34;&gt;Co należy zrobić?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Zaimplementuj rekurencyjną funkcję wiezeHanoi(N:int), która rozwiąże problem i jednocześnie na konsoli wyświetli jakąś wizualizację wykonanych ruchów. (Podpowiedź: Krążki reprezentuj przez liczby naturalne a stosy przez listy.)&lt;/li&gt;
&lt;li&gt;Czy potrafisz wyjaśnić dlaczego zaprezentowany algortym działa?&lt;/li&gt;
&lt;li&gt;Jak zależy ilość przestawień od liczby krążków?&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Sortowanie bąbelkowe</title>
      <link>https://www.rozanskit.com/pl/teaching/jsp2019/bubble_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.rozanskit.com/pl/teaching/jsp2019/bubble_sort/</guid>
      <description>&lt;h3 id=&#34;na-czym-polega-sortowanie-bąbelkowe&#34;&gt;Na czym polega sortowanie bąbelkowe?&lt;/h3&gt;
&lt;p&gt;Wikipedia: &amp;ldquo;[Sortowanie bąbelkowe] Polega na porównywaniu dwóch kolejnych elementów i zamianie ich kolejności, jeżeli zaburza ona porządek, w jakim się sortuje tablicę. Sortowanie kończy się, gdy podczas kolejnego przejścia nie dokonano żadnej zmiany.&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;wizualizacja&#34;&gt;Wizualizacja&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/nmhjrI-aW5o&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;pseudokod&#34;&gt;Pseudokod&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;procedure bubbleSort( A : lista elementów do posortowania )
  n = liczba_elementów(A)
   do
    for (i = 0; i &amp;lt; n-1; i++) do:
      if A[i] &amp;gt; A[i+1] then
        swap(A[i], A[i+1])
      end if
    end for
    n = n-1 # Dlaczego?
  while n &amp;gt; 1
end procedure
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;co-należy-zaimplementować&#34;&gt;Co należy zaimplementować?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Zaimplementuj funkcję bubble_sort(), która jako argument przyjmuje listę a zwraca listę posortowaną.&lt;/li&gt;
&lt;li&gt;W funkcji main() wygeneruj losową listę liczb o długości N=1000.&lt;/li&gt;
&lt;li&gt;Posortuj tę listę wykorzystując bubble_sort().&lt;/li&gt;
&lt;li&gt;Sprawdź czy lista zwrócona przez funkcję jest posortowana.&lt;/li&gt;
&lt;li&gt;Zmierz czas potrzebny na wykonanie sortowania N = {10, 100, 1000, 10000} liczb.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;pytania&#34;&gt;Pytania&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Jak rośnie czas wykonania algorymtu wraz ze wzrostem długości danych N (liniowo, kwadratowo, logarytmicznie, &amp;hellip;)?&lt;/li&gt;
&lt;li&gt;Ile maksymalnie porównań może wykonać zaimplementowane sortowanie (w funkcji N)?&lt;/li&gt;
&lt;li&gt;Czy masz jakieś pomysły na usprawnienie sortowania bąbelkowego?&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Sortowanie przez scalanie</title>
      <link>https://www.rozanskit.com/pl/teaching/jsp2019/merge_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.rozanskit.com/pl/teaching/jsp2019/merge_sort/</guid>
      <description>&lt;h3 id=&#34;na-czym-polega-sortowanie-przez-scalanie&#34;&gt;Na czym polega sortowanie przez scalanie?&lt;/h3&gt;
&lt;p&gt;Algorytm sortowania przez scalanie (ang. &lt;em&gt;merge sort&lt;/em&gt;) wykorzystuje metodę ,,dziel i zwyciężaj&amp;rsquo;&amp;rsquo; (ang. &lt;em&gt;divide-and-conquer&lt;/em&gt;). Algorytmy tego typu wywołują same siebie (jeden lub więcej razy), tzn. mają strukturę rekurencyjną. Metoda ,,dziel i zwyciężaj&amp;rsquo;&amp;rsquo; polega na podzieleniu problemu na mniejsze podproblemy, rozwiązaniu ich a następnie połączeniu rozwiązań podproblemów w celu uzyskania rozwiązania początkowego, pełnego problemu.&lt;/p&gt;
&lt;p&gt;Ogólny opis algorytmu sortowania przez scalanie jest następujący:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Podziel $n$-elementowy ciąg na dwa podciągi po $n/2$ elementów każdy.&lt;/li&gt;
&lt;li&gt;Posortuj otrzymane podciągi, używając rekurencyjnie sortowania przez scalanie.&lt;/li&gt;
&lt;li&gt;Połącz posortowanie podciągi w jeden posortowany ciąg.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rekursja kończy się gdy ciąg do posortowania ma długość równą 1 - ciąg o długości 1 zawsze jest posortowany.&lt;/p&gt;
&lt;p&gt;Kluczowym elementem algorytmu jest procedura $\text{MERGE}(A,p,q,r)$, gdzie $A$ to tablica, a $p,~q,~r$ są indeksami ($p\le q\le r$). Procedura zakłada, że podciągi $A[p..q]$ i $A[q..r]$ są posortowane. Po jej wywołaniu tablica $A[p..r]$ jest posortowana. (&lt;em&gt;Opracowano na podstawie książki T. H. Cormen i in. ,,Wprowadzenie do algorytmów&amp;rsquo;&amp;rsquo;.&lt;/em&gt;)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;







  











&lt;figure id=&#34;figure-sortowanie-przez-scalanie&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://www.rozanskit.com/media/jsp2020/Merge-sort-example-300px.gif&#34; data-caption=&#34;Sortowanie przez scalanie&#34;&gt;


  &lt;img src=&#34;https://www.rozanskit.com/media/jsp2020/Merge-sort-example-300px.gif&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Sortowanie przez scalanie
  &lt;/figcaption&gt;


&lt;/figure&gt;

(Grafika pochodzi z 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Merge_sort#/media/File:Merge-sort-example-300px.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;artykułu w angielskojęzycznej Wikipedii&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&#34;wizualizacja&#34;&gt;Wizualizacja&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/XaqR3G_NVoo&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;pseudokod&#34;&gt;Pseudokod&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;procedure mergeSort( A, p, r)
  // posortuj tablicę A -&amp;gt; mergeSort(A, 0, length(A)-1)
  if p &amp;lt; r
    q = floor((p+r)/2)
    mergeSort(A, p, q)
    mergeSort(A, q+1, r)
    merge(A, p, q, r)
  endif

procedure merge(A, p, q, r)
  n1 = q - p + 1
  n2 = r - q
  L[0..n1] i R[0..n2] to puste tablice
  for i = 0 to n1
    L[i] = A[p+i]
  for i = 0 to n2
    R[j] = A[q+j+1]
  L[n1] = infinity
  L[n2] = infinity
  i = 0
  j = 0
  for k = p to r
    if L[i] &amp;lt;= R[j]
      A[k] = L[i]
      i++
    else
      A[k] = R[j]
      j++
    endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;co-należy-zaimplementować&#34;&gt;Co należy zaimplementować?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Zaimplementuj funkcję merge_sort(), która jako argument przyjmuje listę a zwraca listę posortowaną.&lt;/li&gt;
&lt;li&gt;Porównaj czas sortowania list o długości 5, 10, 50, 100, 1000 elementów przy pomocy algorytmów mergeSort() i insertionSort().&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;pytania&#34;&gt;Pytania&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Jak rośnie czas wykonania algorymtu wraz ze wzrostem długości danych N (liniowo, kwadratowo, logarytmicznie, &amp;hellip;)?&lt;/li&gt;
&lt;li&gt;Czy algorytm sortowania przez scalanie jest zawsze szybszy od algorytmu sortowania przez wstawianie?&lt;/li&gt;
&lt;li&gt;Jak zbudować hybrydę algorytmów sortowania przez scalanie i sortowania przez wstawianie, która będzie szybsza od sortowania przez scalanie?&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Sortowanie przez wstawianie</title>
      <link>https://www.rozanskit.com/pl/teaching/jsp2019/insertion_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.rozanskit.com/pl/teaching/jsp2019/insertion_sort/</guid>
      <description>&lt;h3 id=&#34;na-czym-polega-sortowanie-przez-wstawianie&#34;&gt;Na czym polega sortowanie przez wstawianie?&lt;/h3&gt;
&lt;p&gt;Na podstawie książki T. H. Cormen i in. ,,Wprowadzenie do algorytmów&amp;rsquo;&#39;: Sortowanie przez wstawianie jest efektywnym algorytmem sortowania dla niewielkiej liczby elementów. Algorytm ten działa w taki sposób,  jaki ludzie często porządkują rozdane karty. Zaczynamy od ,,pustej&amp;rsquo;&amp;rsquo; lewej ręki i kupki kart zakrytych na stole. Następnie bierzemy ze stołu kolejno po jednej karcie i wstawiamy ją we właściwe miejsce wśród kart trzymanych w lewej ręce. Aby znaleźć włąściwe miejsce dla danej karty, porównujemy ją z kartami, które już mamy w ręce, przeglądając je od strony prawej do lewej. Przez cały czas karty trzymane w lewej ręce są posortowane, a kart na stole znajdują się w losowej kolejności.&lt;/p&gt;
&lt;h3 id=&#34;wizualizacja&#34;&gt;Wizualizacja&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/OGzPmgsI-pQ&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;pseudokod&#34;&gt;Pseudokod&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;procedure insertionSort( A : lista elementów do posortowania )
  n = liczba_elementów(A)
  for (i = 1; i &amp;lt; n; i++) do
    key = A[i]
    //Wstaw A[j] w posortowany ciąg A[0:i]
    j = i - 1
    while (j &amp;gt;= 0) and (A[j] &amp;gt; key)
      A[j+1] = A[j]
      j -= 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;co-należy-zaimplementować&#34;&gt;Co należy zaimplementować?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Zaimplementuj funkcję insert_sort(), która jako argument przyjmuje listę a zwraca listę posortowaną.&lt;/li&gt;
&lt;li&gt;W funkcji main() wygeneruj losową listę liczb o długości N=1000.&lt;/li&gt;
&lt;li&gt;Posortuj tę listę wykorzystując insert_sort().&lt;/li&gt;
&lt;li&gt;Sprawdź czy lista zwrócona przez funkcję jest posortowana.&lt;/li&gt;
&lt;li&gt;Zmierz czas potrzebny na wykonanie sortowania N = {10, 100, 1000, 10000} liczb.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;pytania&#34;&gt;Pytania&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Jak rośnie czas wykonania algorymtu wraz ze wzrostem długości danych N (liniowo, kwadratowo, logarytmicznie, &amp;hellip;)?&lt;/li&gt;
&lt;li&gt;Czy masz jakieś pomysły na usprawnienie sortowania przez wstawianie (zmniejszenie liczby porównań, zmiejszenie liczy przestawień)?&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Sortowanie szybkie</title>
      <link>https://www.rozanskit.com/pl/teaching/jsp2019/quick_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.rozanskit.com/pl/teaching/jsp2019/quick_sort/</guid>
      <description>&lt;h3 id=&#34;na-czym-polega-sortowanie-szybkie&#34;&gt;Na czym polega sortowanie szybkie?&lt;/h3&gt;
&lt;p&gt;Algorytm sortowania szybkiego (ang. &lt;em&gt;quick sort&lt;/em&gt;), podobnie jak sortowanie przez scalanie, wykorzystuje metodę ,,dziel i zwyciężaj&amp;rsquo;&amp;rsquo; (ang. &lt;em&gt;divide-and-conquer&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Ogólny opis algorytmu quicksort jest następujący:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wybierz element tablicy zwany z angielskiego &lt;em&gt;pivot&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Podziel tablicę na dwie części - zawierającym elementy większe i elementy mniejsze od pivota. Po tym kroku tablica sortowana powinna wyglądać następująco: [elementy&amp;lt;pivot, pivot, elementy&amp;gt;pivot].&lt;/li&gt;
&lt;li&gt;Zastosuj tę strategię rekurencyjnie dla obydwu części.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rekursja kończy się gdy ciąg do posortowania ma długość równą 1 - ciąg o długości 1 zawsze jest posortowany.&lt;/p&gt;
&lt;p&gt;Kluczowym elementem algorytmu jest procedura partycjonowania (ang. &lt;em&gt;partitioning&lt;/em&gt;). Istnieje kilka różnych strategii wykonywania podziału. Drugin ważnym elementem sortowania szybkiego jest metoda wyboru pivota. Typowo wykorzystuje się element ostatni, ale schemat jego wyboru jest dowolny. Optymalny pivot to taki który dzieli nam tablicę na dwie równe części.&lt;/p&gt;
&lt;hr&gt;








  











&lt;figure id=&#34;figure-sortowanie-szybkie&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://www.rozanskit.com/media/jsp2020/Sorting_quicksort_anim.gif&#34; data-caption=&#34;Sortowanie szybkie&#34;&gt;


  &lt;img src=&#34;https://www.rozanskit.com/media/jsp2020/Sorting_quicksort_anim.gif&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Sortowanie szybkie
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;(Grafika pochodzi z 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Quicksort#/media/File:Sorting_quicksort_anim.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;artykułu w angielskojęzycznej Wikipedii&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&#34;wizualizacja&#34;&gt;Wizualizacja&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/PgBzjlCcFvc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;pseudokod&#34;&gt;Pseudokod&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;algorithm quick_sort(A, lo, hi) is
    if lo &amp;lt; hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p)
        quicksort(A, p + 1, hi)

algorithm partition(A, lo, hi) is
    &amp;quot;&amp;quot;&amp;quot;
    Hoare partitioning method (1959)
    &amp;quot;&amp;quot;&amp;quot;
    pivot := A[lo + (hi - lo) / 2]
    i := lo - 1
    j := hi + 1
    loop forever
        do
            i := i + 1
        while A[i] &amp;lt; pivot
        do
            j := j - 1
        while A[j] &amp;gt; pivot
        if i &amp;gt;= j then
            return j
        swap A[i] with A[j]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aby posortować tablicę A należy wywołać zaimplementowaną funckję następująco: quick_sort(A, 0, len(A)-1).&lt;/p&gt;
&lt;h3 id=&#34;co-należy-zaimplementować&#34;&gt;Co należy zaimplementować?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Zaimplementuj funkcję quick_sort(), która jako argument przyjmuje listę a zwraca listę posortowaną.&lt;/li&gt;
&lt;li&gt;Porównaj czas sortowania list o długości 5, 10, 50, 100, 1000 elementów przy pomocy algorytmów quick_sort() i merge_sort().&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;pytania&#34;&gt;Pytania&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Jak rośnie czas wykonania algorymtu wraz ze wzrostem długości danych N (liniowo, kwadratowo, logarytmicznie, &amp;hellip;)?&lt;/li&gt;
&lt;li&gt;Jaka jest największa słabość algorytmu sortowania szybkiego?&lt;/li&gt;
&lt;li&gt;Jakie znasz metody wyboru pivota? Która jest najlepsza?&lt;/li&gt;
&lt;li&gt;Czym jest zrandomizowany quicksort?&lt;/li&gt;
&lt;li&gt;Czy algorytm sortowania szybkiego jest zawsze szybszy od algorytmu sortowania przez scalanie? Dlaczego?&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Wprowadzenie do systemu kontroli wersji - Git</title>
      <link>https://www.rozanskit.com/pl/teaching/jsp2019/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.rozanskit.com/pl/teaching/jsp2019/git/</guid>
      <description>&lt;h3 id=&#34;literatura&#34;&gt;Literatura&lt;/h3&gt;
&lt;p&gt;Wszystkie informacje zamieszczone poniżej, pochodzą z doskonałego wprowadzenia do systemu kontroli wersji Git, które można znaleźć w książce: 
&lt;a href=&#34;https://git-scm.com/book/pl/v2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pro Git (S. Chacon, B. Straub)&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;co-to-jest-system-kontroli-wersji-i-dlaczego-go-potrzebujemy&#34;&gt;Co to jest system kontroli wersji i dlaczego go potrzebujemy?&lt;/h3&gt;
&lt;p&gt;Systemy kontroli wersji służą śledzeniu i zapamiętywaniu wszystkich zmian wprowadzanych w projekcie nad, którym pracujemy. Zmiany mogą dotyczyć zmian w kodzie źródłowym programu, ale nie tylko - mogą to być zmiany dowolnych plików (lub w plikach). Dzięki historii zmian możemy w dowolnym momencie przywrócić wcześniejszy stan projektu, czy sprawdzić kto jest autorem danego fragmentu kodu.&lt;/p&gt;
&lt;p&gt;Prawdziwa wartość systemów kontroli wersji jest widoczna w pracy grupowej, kiedy wielu programistów jednocześnie pracuje nad przydzielonymi im funkcjonalnościami oprogramowania. Wtedy uporządkowana praca pozwala na łatwe rozszerzanie możliwości programu i rozwiązywanie konfliktów, czyli problemów które mogą wystąpić podczas scalania zmian wykonanych przez dwóch programistów w tym samym pliku.&lt;/p&gt;
&lt;h3 id=&#34;quick-start&#34;&gt;Quick start&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Utwórz katalog, który będzie twoim katalogiem projektu.&lt;/li&gt;
&lt;li&gt;Wejdź do nowo utworzonego katalogu i zainicjalizuj w nim&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
